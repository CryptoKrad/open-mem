/**
 * Open-Mem — OpenClaw Native Hook (Production-Grade)
 *
 * Captures tool calls from OpenClaw sessions into Open-Mem with:
 *   - Noise filtering (skips memory_search, tts, canvas, cron, etc.)
 *   - Response trimming (6k cap before queuing)
 *   - Session init with user goal capture
 *   - Prompt counter tracking per session
 *
 * Place this file at: ~/.openclaw/hooks/open-mem/handler.ts
 *
 * Then add to your openclaw.json:
 *   "hooks": {
 *     "internal": {
 *       "entries": {
 *         "open-mem": { "enabled": true }
 *       }
 *     }
 *   }
 *
 * See examples/openclaw-hook/README.md for full setup guide.
 *
 * Requires OpenClaw ≥ 2026.2.18 (internal hook: tool:after_call)
 */

import type { HookHandler } from "openclaw/hooks";
import { readFileSync, existsSync } from "fs";
import { homedir } from "os";
import { join } from "path";

// ── Config ──────────────────────────────────────────────────────────────────

const WORKER_URL = process.env.OPEN_MEM_URL ?? "http://127.0.0.1:37888";

// Auth token generated by Open-Mem on first run (~/.open-mem/auth.token)
const TOKEN_PATH =
  process.env.OPEN_MEM_TOKEN_PATH ??
  join(homedir(), ".open-mem", "auth.token");

// Project namespace — set OPEN_MEM_PROJECT or defaults to "default"
const PROJECT = process.env.OPEN_MEM_PROJECT ?? "default";

// ── Noise filter — tools with no persistent memory value ────────────────────
// Add tool names here to skip them entirely (exact match).
const SKIP_TOOLS = new Set([
  "memory_search",      // circular — don't memorize memory lookups
  "memory_get",         // same
  "session_status",     // meta overhead
  "tts",                // audio output, no code content
  "canvas",             // UI snapshots
  "cron",               // cron management, not work product
  "subagents",          // orchestration meta
  "sessions_list",      // ephemeral listing
  "sessions_history",   // reading history, not producing it
  "agents_list",        // static config
]);

// Response size limits
const MAX_RESPONSE_CHARS = 6_000;   // trim before queuing (compressor caps at 8k anyway)
const MIN_RESPONSE_CHARS = 20;      // skip near-empty responses

// ── Auth ────────────────────────────────────────────────────────────────────

function readAuthToken(): string | undefined {
  try {
    if (existsSync(TOKEN_PATH)) {
      return readFileSync(TOKEN_PATH, "utf-8").trim() || undefined;
    }
  } catch { /* no token */ }
  return undefined;
}

const AUTH_TOKEN = readAuthToken();

function authHeaders(): Record<string, string> {
  return AUTH_TOKEN ? { Authorization: `Bearer ${AUTH_TOKEN}` } : {};
}

// ── Health check ─────────────────────────────────────────────────────────────

async function checkHealth(): Promise<boolean> {
  try {
    const res = await fetch(`${WORKER_URL}/api/health`, {
      signal: AbortSignal.timeout(2_000),
    });
    return res.ok;
  } catch {
    return false;
  }
}

// ── State ────────────────────────────────────────────────────────────────────

/** Tracks prompt number per session for observation ordering */
const promptCounters = new Map<string, number>();

/** Tracks which sessions have been initialized (avoids duplicate init calls) */
const initializedSessions = new Set<string>();

// ── API helpers ──────────────────────────────────────────────────────────────

function initSession(sessionId: string, project: string, userGoal: string): void {
  if (initializedSessions.has(sessionId)) return;
  initializedSessions.add(sessionId);
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 3_000);
  fetch(`${WORKER_URL}/api/sessions/init`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ session_id: sessionId, project, userPrompt: userGoal }),
    signal: controller.signal,
  }).then(() => clearTimeout(timer)).catch(() => clearTimeout(timer));
}

function postObservation(
  sessionId: string,
  toolName: string,
  toolInput: unknown,
  toolResponse: string,
  promptNumber: number
): void {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 3_000);
  fetch(`${WORKER_URL}/api/observations`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({
      session_id: sessionId,
      project: PROJECT,
      tool_name: toolName,
      tool_input: toolInput,
      tool_response: toolResponse,
      prompt_number: promptNumber,
    }),
    signal: controller.signal,
  }).then(() => clearTimeout(timer)).catch(() => clearTimeout(timer));
  // Fire-and-forget — never blocks OpenClaw
}

function postSessionComplete(sessionId: string, reason: string): void {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 2_000);
  fetch(`${WORKER_URL}/api/sessions/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ session_id: sessionId, reason }),
    signal: controller.signal,
  }).then(() => clearTimeout(timer)).catch(() => clearTimeout(timer));
}

// ── Hook handler ─────────────────────────────────────────────────────────────

const handler: HookHandler = async (event) => {
  // ── Gateway startup: verify Open-Mem is reachable ───────────────────────
  if (event.type === "gateway" && event.action === "startup") {
    const alive = await checkHealth();
    if (!alive) {
      process.stderr.write(
        `[open-mem] ⚠️  Worker not reachable at ${WORKER_URL} — memory unavailable\n`
      );
    }
    return;
  }

  // ── Session boundaries ──────────────────────────────────────────────────
  if (event.type === "command") {
    const session = (event as { sessionKey?: string }).sessionKey ?? "unknown";
    const action = (event as { action: string }).action;
    switch (action) {
      case "stop":
        postSessionComplete(session, "command:stop");
        promptCounters.delete(session);
        initializedSessions.delete(session);
        break;
      case "new":
      case "reset":
        postSessionComplete(session, `command:${action}`);
        promptCounters.delete(session);
        initializedSessions.delete(session);
        break;
    }
    return;
  }

  // ── Before tool: init session on first tool call ─────────────────────────
  if (event.type === "tool" && event.action === "before_call") {
    if (!event.sessionKey) return;
    if (!initializedSessions.has(event.sessionKey)) {
      const ctx = event.context as { userMessage?: string };
      const goal = (ctx.userMessage as string | undefined)?.slice(0, 300)
        ?? `Session ${event.sessionKey}`;
      initSession(event.sessionKey, PROJECT, goal);
    }
    return;
  }

  // ── After tool: capture observation ─────────────────────────────────────
  if (event.type === "tool" && event.action === "after_call") {
    if (!event.sessionKey) return;

    const ctx = event.context as {
      toolName?: string;
      params?: unknown;
      result?: unknown;
      error?: string;
    };

    const toolName = ctx.toolName ?? "unknown_tool";

    // Skip noise tools
    if (SKIP_TOOLS.has(toolName)) return;

    const toolResponse = ctx.error
      ? `ERROR: ${ctx.error}`
      : typeof ctx.result === "string"
        ? ctx.result
        : JSON.stringify(ctx.result ?? "");

    // Skip trivially empty responses
    if (toolResponse.length < MIN_RESPONSE_CHARS) return;

    // Trim oversized responses before queuing
    const trimmed = toolResponse.length > MAX_RESPONSE_CHARS
      ? toolResponse.slice(0, MAX_RESPONSE_CHARS) + "\n[...trimmed]"
      : toolResponse;

    // Increment prompt counter for this session
    const sessionId = event.sessionKey;
    const promptNumber = (promptCounters.get(sessionId) ?? 0) + 1;
    promptCounters.set(sessionId, promptNumber);

    postObservation(sessionId, toolName, ctx.params ?? {}, trimmed, promptNumber);
  }
};

export default handler;
