/**
 * Open-Mem — OpenClaw Native Hook
 *
 * Captures every tool call from OpenClaw sessions into Open-Mem.
 * Place this file at: ~/.openclaw/hooks/open-mem/handler.ts
 *
 * Then add to your openclaw.json:
 *   "hooks": {
 *     "internal": {
 *       "entries": {
 *         "open-mem": { "enabled": true }
 *       }
 *     }
 *   }
 *
 * See examples/openclaw-hook/README.md for full setup guide.
 */

import type { HookHandler } from "openclaw/hooks";
import { readFileSync, existsSync } from "fs";
import { homedir } from "os";
import { join, basename } from "path";

// ── Config ──────────────────────────────────────────────────────────────────

const WORKER_URL = process.env.OPEN_MEM_URL ?? "http://127.0.0.1:37888";

// Auth token generated by Open-Mem on first run
const TOKEN_PATH =
  process.env.OPEN_MEM_TOKEN_PATH ??
  join(homedir(), ".open-mem", "auth.token");

// Project namespace — defaults to the CWD basename so each repo gets its own memory
const PROJECT =
  process.env.OPEN_MEM_PROJECT ??
  basename(process.cwd());

// ── Auth ────────────────────────────────────────────────────────────────────

function readAuthToken(): string | undefined {
  try {
    if (existsSync(TOKEN_PATH)) {
      return readFileSync(TOKEN_PATH, "utf-8").trim() || undefined;
    }
  } catch {
    // Worker running without auth (development mode)
  }
  return undefined;
}

const AUTH_TOKEN = readAuthToken();

function authHeaders(): Record<string, string> {
  return AUTH_TOKEN ? { Authorization: `Bearer ${AUTH_TOKEN}` } : {};
}

// ── Helpers ─────────────────────────────────────────────────────────────────

async function checkHealth(): Promise<boolean> {
  try {
    const res = await fetch(`${WORKER_URL}/health`, {
      signal: AbortSignal.timeout(2_000),
    });
    return res.ok;
  } catch {
    return false;
  }
}

/** Fire-and-forget — never blocks OpenClaw */
function postObservation(
  sessionId: string,
  toolName: string,
  toolInput: unknown,
  toolResponse: string
): void {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 2_000);
  fetch(`${WORKER_URL}/api/observations`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({
      session_id: sessionId,
      project: PROJECT,
      tool_name: toolName,
      tool_input: toolInput,
      tool_response: toolResponse,
    }),
    signal: controller.signal,
  })
    .then(() => clearTimeout(timer))
    .catch(() => clearTimeout(timer));
}

/** Fire-and-forget session close signal */
function postSessionComplete(sessionId: string, reason: string): void {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 2_000);
  fetch(`${WORKER_URL}/api/sessions/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ session_id: sessionId, reason }),
    signal: controller.signal,
  })
    .then(() => clearTimeout(timer))
    .catch(() => clearTimeout(timer));
}

// ── Hook handler ─────────────────────────────────────────────────────────────

const handler: HookHandler = async (event) => {
  // ── Gateway startup: verify Open-Mem worker is reachable ────────────────
  if (event.type === "gateway" && event.action === "startup") {
    const alive = await checkHealth();
    if (!alive) {
      process.stderr.write(
        `[open-mem] ⚠️  Worker not reachable at ${WORKER_URL} — memory capture unavailable\n`
      );
    }
    return;
  }

  // ── Session boundaries ────────────────────────────────────────────────────
  if (event.type === "command") {
    const session = (event as { sessionKey?: string }).sessionKey ?? "unknown";
    const action = (event as { action: string }).action;
    if (action === "stop" || action === "new" || action === "reset") {
      postSessionComplete(session, `command:${action}`);
    }
    return;
  }

  // ── Tool call observation ─────────────────────────────────────────────────
  if (event.type === "tool" && event.action === "after_call") {
    // Two bridge points fire per call; the adapter passes "" — skip it
    if (!event.sessionKey) return;

    const ctx = event.context as {
      toolName?: string;
      params?: unknown;
      result?: unknown;
      error?: string;
    };

    const toolName = ctx.toolName ?? "unknown_tool";
    const toolInput = ctx.params ?? {};
    const toolResponse = ctx.error
      ? `ERROR: ${ctx.error}`
      : typeof ctx.result === "string"
        ? ctx.result
        : JSON.stringify(ctx.result ?? "");

    postObservation(event.sessionKey, toolName, toolInput, toolResponse);
  }
};

export default handler;
